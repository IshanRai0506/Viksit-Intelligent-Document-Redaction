import os
import re
from flask import Flask, request, jsonify, Response
from flask_cors import CORS
from werkzeug.utils import secure_filename
from PIL import Image
import pytesseract
from pdf2image import convert_from_path
import spacy
import io

# --- CONFIGURATION ---
UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'tiff', 'pdf'}

# --- MODEL LOADING ---
# Load the spaCy model once at startup for efficiency
print("Loading spaCy model...")
try:
    nlp = spacy.load("en_core_web_sm")
    print("spaCy model loaded successfully.")
except OSError:
    print("spaCy model not found. Please run 'python -m spacy download en_core_web_sm'")
    nlp = None # Handle gracefully if model is not downloaded

# --- FLASK APP INITIALIZATION ---
app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
CORS(app) # Enable Cross-Origin Resource Sharing

# Create the upload folder if it doesn't exist
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# --- EMBEDDED FRONTEND ---
# The entire HTML, CSS, and JavaScript is stored in this string.
# The JavaScript's fetch URL has been changed to '/redact' to call the backend on the same server.
HTML_CONTENT = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viksit - Document Redaction Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(45deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; font-weight: 700; }
        .header p { font-size: 1.1rem; opacity: 0.9; }
        .main-content { padding: 40px; }
        .upload-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            border: 3px dashed #ddd;
            transition: all 0.3s ease;
        }
        .upload-section.dragover { border-color: #3498db; background: #e3f2fd; }
        .upload-icon { font-size: 4rem; color: #3498db; margin-bottom: 20px; }
        .file-input { display: none; }
        .upload-btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white; padding: 15px 30px; border: none;
            border-radius: 25px; font-size: 1.1rem; cursor: pointer;
            transition: transform 0.3s ease;
        }
        .upload-btn:hover { transform: translateY(-2px); }
        .file-info { margin-top: 20px; padding: 15px; background: #e8f5e8; border-radius: 10px; border-left: 4px solid #27ae60; }
        .processing-section { display: none; text-align: center; padding: 40px; background: #fff3cd; border-radius: 15px; margin-bottom: 30px; }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db; border-radius: 50%;
            animation: spin 1s linear infinite; margin: 0 auto 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .results-section { display: none; }
        .preview-container { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        .preview-box { background: #f8f9fa; border-radius: 15px; padding: 20px; border: 1px solid #ddd; }
        .preview-box h3 { margin-bottom: 15px; color: #2c3e50; font-size: 1.3rem; }
        canvas.document-preview { width: 100%; border-radius: 10px; border: 1px solid #ddd; background: white; }
        .redaction-stats { background: #e8f4fd; border-radius: 15px; padding: 20px; margin-bottom: 20px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .stat-item { text-align: center; padding: 15px; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .stat-number { font-size: 2rem; font-weight: bold; color: #3498db; }
        .stat-label { color: #666; font-size: 0.9rem; margin-top: 5px; }
        .redaction-log { background: white; border-radius: 10px; padding: 20px; max-height: 300px; overflow-y: auto; border: 1px solid #ddd; }
        .log-item { padding: 8px 12px; margin-bottom: 8px; border-radius: 5px; font-size: 0.9rem; }
        .log-item.pii { background: #ffebee; border-left: 4px solid #f44336; }
        .log-item.phi { background: #e8f5e8; border-left: 4px solid #4caf50; }
        .log-item.financial { background: #fff3e0; border-left: 4px solid #ff9800; }
        .log-item.signature { background: #f3e5f5; border-left: 4px solid #9c27b0; }
        .download-section { text-align: center; padding: 30px; background: #f0f8ff; border-radius: 15px; }
        .download-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white; padding: 15px 30px; border: none;
            border-radius: 25px; font-size: 1.1rem; cursor: pointer; margin: 0 10px;
            transition: transform 0.3s ease;
        }
        .download-btn:hover { transform: translateY(-2px); }
        .error-message { color: #c0392b; background: #ffebee; border: 1px solid #c0392b; padding: 15px; border-radius: 10px; margin-top: 20px; }
        @media (max-width: 768px) {
            .preview-container { grid-template-columns: 1fr; }
            .header h1 { font-size: 2rem; }
            .main-content { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è Viksit - Intelligent Document Redaction</h1>
            <p>Secure your sensitive documents with our AI-powered tool</p>
        </div>
        <div class="main-content">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÑ</div>
                <h2>Upload Your Document</h2>
                <p>Supports PDF, PNG, JPEG, TIFF formats</p>
                <input type="file" id="fileInput" class="file-input" accept=".pdf,.png,.jpg,.jpeg,.tiff" />
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
                <div id="fileInfo" class="file-info" style="display: none;"></div>
            </div>
            <div class="processing-section" id="processingSection">
                <div class="spinner"></div>
                <h2>Processing Document...</h2>
                <p id="processingStatus">This may take a moment for large files.</p>
            </div>
            <div class="results-section" id="resultsSection">
                <div class="redaction-stats">
                    <h2>Redaction Summary</h2>
                    <div class="stats-grid">
                        <div class="stat-item"><div class="stat-number" id="totalRedactions">0</div><div class="stat-label">Total Redactions</div></div>
                        <div class="stat-item"><div class="stat-number" id="piiCount">0</div><div class="stat-label">Personal Info</div></div>
                        <div class="stat-item"><div class="stat-number" id="phiCount">0</div><div class="stat-label">Health Info</div></div>
                        <div class="stat-item"><div class="stat-number" id="financialCount">0</div><div class="stat-label">Financial Data</div></div>
                        <div class="stat-item"><div class="stat-number" id="signatureCount">0</div><div class="stat-label">Signatures</div></div>
                    </div>
                </div>
                <div class="preview-container">
                    <div class="preview-box">
                        <h3>Original Document</h3>
                        <canvas id="originalCanvas" class="document-preview"></canvas>
                    </div>
                    <div class="preview-box">
                        <h3>Redacted Document</h3>
                        <canvas id="redactedCanvas" class="document-preview"></canvas>
                    </div>
                </div>
                <div class="preview-box">
                    <h3>Redaction Log</h3>
                    <div id="redactionLog" class="redaction-log"></div>
                </div>
                <div class="download-section">
                    <h2>Download Results</h2>
                    <button class="download-btn" id="downloadDoc">üìÑ Download Redacted Document</button>
                    <button class="download-btn" id="downloadLog">üìã Download Audit Log</button>
                    <button class="download-btn" onclick="resetApp()" style="background: linear-gradient(45deg, #95a5a6, #7f8c8d);">üîÑ Process Another Document</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        let currentFile = null;
        let redactionData = null;

        const uploadSection = document.getElementById('uploadSection');
        uploadSection.addEventListener('dragover', (e) => { e.preventDefault(); uploadSection.classList.add('dragover'); });
        uploadSection.addEventListener('dragleave', () => uploadSection.classList.remove('dragover'));
        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleFile(e.target.files[0]);
        });

        function handleFile(file) {
            currentFile = file;
            const fileInfo = document.getElementById('fileInfo');
            fileInfo.innerHTML = `
                <strong>Selected:</strong> ${file.name} 
                <span style="color: #666;">(${(file.size / 1024 / 1024).toFixed(2)} MB)</span><br>
                <button class="upload-btn" onclick="processDocument()" style="margin-top: 10px;">üöÄ Process Document</button>
                <div id="apiError" class="error-message" style="display: none; margin-top: 15px;"></div>
            `;
            fileInfo.style.display = 'block';
        }

        async function processDocument() {
            if (!currentFile) return;
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('processingSection').style.display = 'block';
            document.getElementById('processingStatus').textContent = 'Uploading and processing... please wait.';
            
            const formData = new FormData();
            formData.append('file', currentFile);

            try {
                // IMPORTANT: This now points to a relative URL, so it calls the same server.
                const response = await fetch('/redact', { method: 'POST', body: formData });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! Status: ${response.status}`);
                }

                redactionData = await response.json();
                
                updateRedactionStats(redactionData);
                await createDocumentPreviews(currentFile, redactionData);
                generateRedactionLog(redactionData);
                
                document.getElementById('processingSection').style.display = 'none';
                document.getElementById('resultsSection').style.display = 'block';

            } catch (error) {
                console.error("Error processing document:", error);
                const errorDiv = document.getElementById('apiError') || document.createElement('div');
                if(!document.getElementById('apiError')){
                    errorDiv.id = 'apiError';
                    errorDiv.className = 'error-message';
                    document.getElementById('fileInfo').appendChild(errorDiv);
                }
                errorDiv.textContent = `An error occurred: ${error.message}. Please try again.`;
                errorDiv.style.display = 'block';
                document.getElementById('processingSection').style.display = 'none';
                document.getElementById('uploadSection').style.display = 'block';
            }
        }

        function updateRedactionStats(data) {
            const counts = { pii: 0, phi: 0, financial: 0, signature: 0 };
            (data.redactions || []).forEach(redaction => {
                counts[redaction.type] = (counts[redaction.type] || 0) + 1;
            });
            document.getElementById('totalRedactions').textContent = data.totalRedactions || 0;
            document.getElementById('piiCount').textContent = counts.pii;
            document.getElementById('phiCount').textContent = counts.phi;
            document.getElementById('financialCount').textContent = counts.financial;
            document.getElementById('signatureCount').textContent = counts.signature;
        }

        async function createDocumentPreviews(file, redactionData) {
            const originalCanvas = document.getElementById('originalCanvas');
            const redactedCanvas = document.getElementById('redactedCanvas');
            const ctx1 = originalCanvas.getContext('2d');
            const ctx2 = redactedCanvas.getContext('2d');

            const reader = new FileReader();
            reader.readAsDataURL(file);
            await new Promise(resolve => reader.onload = resolve);
            
            // For this version, we will always render the image preview
            const img = new Image();
            img.src = reader.result;
            await new Promise(resolve => img.onload = resolve);

            const maxWidth = 500;
            let { width, height } = img;
            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            originalCanvas.width = redactedCanvas.width = width;
            originalCanvas.height = redactedCanvas.height = height;

            ctx1.drawImage(img, 0, 0, width, height);
            ctx2.drawImage(img, 0, 0, width, height);

            ctx2.fillStyle = 'black';
            (redactionData.redactions || []).forEach(r => {
                const scaleX = width / r.page_width;
                const scaleY = height / r.page_height;
                ctx2.fillRect(r.x * scaleX, r.y * scaleY, r.width * scaleX, r.height * scaleY);
            });
        }

        function generateRedactionLog(data) {
            const logContainer = document.getElementById('redactionLog');
            logContainer.innerHTML = '';
            (data.redactions || []).forEach(redaction => {
                const logItem = document.createElement('div');
                logItem.className = `log-item ${redaction.type}`;
                logItem.innerHTML = `
                    <strong>${redaction.category}</strong>: ${redaction.value}
                    <span style="float: right; font-size: 0.8em; opacity: 0.7;">
                        ${(redaction.confidence * 100).toFixed(1)}% conf.
                    </span>
                `;
                logContainer.appendChild(logItem);
            });
        }

        document.getElementById('downloadDoc').addEventListener('click', () => {
            const canvas = document.getElementById('redactedCanvas');
            const link = document.createElement('a');
            link.download = `redacted_${currentFile.name.split('.')[0]}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        document.getElementById('downloadLog').addEventListener('click', () => {
            const logBlob = new Blob([JSON.stringify(redactionData, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `redaction_log_${currentFile.name.split('.')[0]}.json`;
            link.href = URL.createObjectURL(logBlob);
            link.click();
        });

        function resetApp() {
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('fileInfo').style.display = 'none';
            document.getElementById('fileInput').value = '';
            currentFile = null;
            redactionData = null;
        }
    </script>
</body>
</html>
"""

# --- BACKEND HELPER FUNCTIONS ---

def allowed_file(filename):
    """Checks if the uploaded file has an allowed extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def find_financial_data(text):
    """Finds credit card-like numbers using a simple regex."""
    cc_pattern = re.compile(r'\b(?:\d[ -]*?){13,16}\b')
    return cc_pattern.findall(text)

def process_image(image_bytes):
    """
    Processes a single image (as bytes) to extract text, perform NER, and find sensitive data.
    Returns a list of redaction dictionaries.
    """
    if not nlp:
        # If spaCy model isn't loaded, we can't process.
        return [] 
        
    redactions = []
    try:
        img = Image.open(io.BytesIO(image_bytes))
        page_width, page_height = img.size

        # 1. OCR to get detailed data (text, coordinates, confidence)
        ocr_data = pytesseract.image_to_data(img, output_type=pytesseract.Output.DICT)
        
        # Combine all words into a single string for NER processing
        full_text = " ".join(word for word in ocr_data['text'] if word.strip())

        # 2. NER with spaCy to find PII/PHI
        doc = nlp(full_text)
        
        # For simplicity, this example does a basic word-based lookup.
        # A more advanced implementation would map character offsets from spaCy entities
        # back to the OCR word boxes for higher accuracy.
        for ent in doc.ents:
            for i, word in enumerate(ocr_data['text']):
                if word in ent.text and int(ocr_data['conf'][i]) > 40:
                    redactions.append({
                        "type": "pii" if ent.label_ in ['PERSON', 'GPE', 'ORG', 'DATE'] else 'phi',
                        "category": ent.label_,
                        "value": ent.text,
                        "confidence": 0.95,
                        "x": ocr_data['left'][i],
                        "y": ocr_data['top'][i],
                        "width": ocr_data['width'][i],
                        "height": ocr_data['height'][i],
                        "page_width": page_width,
                        "page_height": page_height
                    })
                    # Break after finding the first word of an entity to avoid duplicates
                    break

        # 3. Signature Detection (Placeholder using keyword)
        # TODO: Replace this with a real object detection model (like one trained on SignverOD)
        for i, text in enumerate(ocr_data['text']):
            if "signature" in text.lower() and int(ocr_data['conf'][i]) > 40:
                redactions.append({
                    "type": "signature", "category": "Signature", "value": "[Signature Block]",
                    "confidence": 0.90, "x": ocr_data['left'][i], "y": ocr_data['top'][i],
                    "width": ocr_data['width'][i] + 50, "height": ocr_data['height'][i] + 20,
                    "page_width": page_width, "page_height": page_height
                })

        # 4. Financial Data Detection
        found_financial = find_financial_data(full_text)
        for item in found_financial:
            for i, text in enumerate(ocr_data['text']):
                if item.replace(" ", "") in text.replace(" ", "") and int(ocr_data['conf'][i]) > 40:
                     redactions.append({
                        "type": "financial", "category": "Credit Card", "value": f"****-****-****-{item[-4:]}",
                        "confidence": 0.99, "x": ocr_data['left'][i], "y": ocr_data['top'][i],
                        "width": ocr_data['width'][i], "height": ocr_data['height'][i],
                        "page_width": page_width, "page_height": page_height
                    })
                     break

    except Exception as e:
        print(f"Error processing image: {e}")
        return []

    return redactions


# --- FLASK ROUTES ---

@app.route('/')
def index():
    """Serves the main HTML page."""
    return Response(HTML_CONTENT, mimetype='text/html')

@app.route('/redact', methods=['POST'])
def redact_document():
    """Handles the file upload and redaction process."""
    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400
    
    file = request.files['file']
    
    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400
        
    if file and allowed_file(file.filename):
        try:
            filename = secure_filename(file.filename)
            file_bytes = file.read() # Read file into memory
            all_redactions = []
            
            if filename.lower().endswith('.pdf'):
                # Convert PDF to a list of images (Pillow objects)
                images = convert_from_path(None, poppler_path=None, first_page=1, last_page=1, fmt='png', userpw=None, thread_count=1, paths_only=False, pdf_file=file_bytes)
                
                # For simplicity, we process only the first page of the PDF
                if images:
                    with io.BytesIO() as output:
                        images[0].save(output, format="PNG")
                        image_bytes_for_processing = output.getvalue()
                    all_redactions.extend(process_image(image_bytes_for_processing))
            else: # It's an image
                all_redactions.extend(process_image(file_bytes))
            
            # De-duplicate redactions based on proximity
            # (A simple de-duplication to avoid overlapping boxes for the same entity)
            unique_redactions = []
            for r in all_redactions:
                is_duplicate = False
                for ur in unique_redactions:
                    # Check if boxes are very close
                    if abs(r['x'] - ur['x']) < 10 and abs(r['y'] - ur['y']) < 10:
                        is_duplicate = True
                        break
                if not is_duplicate:
                    unique_redactions.append(r)

            response_data = {
                "totalRedactions": len(unique_redactions),
                "redactions": unique_redactions
            }
            return jsonify(response_data)

        except Exception as e:
            print(f"An error occurred during processing: {e}")
            return jsonify({"error": f"An unexpected error occurred: {e}"}), 500
        
    return jsonify({"error": "File type not allowed"}), 400

# --- MAIN EXECUTION ---
if __name__ == '__main__':
    # Use host='0.0.0.0' to make the server accessible on your local network
    app.run(host='0.0.0.0', port=5000, debug=True)
